Во время выполнения второй сессии нам нужно будет работать с табличными данными и их визуализацией, для этого нам понадобятся библиотека pandas и библиотека matplotlib

import pandas as pd              #библиотека для работы с большими файлами

import matplotlib.pyplot as plt  #библиотека для работы с визуализацией данных

Для начала работы мы импортируем полученную таблицу из сессии 1

df = pd.read_csv('result.csv') #загрузка файла из Сессии 1 для дальнейшей работы
Следуя заданию, нам необходимо создать новый атрибут, содержащий в себе геоданные и визуализировать его зависимости. Второе, классифицировать группы пользователей.

 

В качестве основных геоданных, мы возьмем город покупки, его мы можем взять из колонки LOCATION_NAME, для этого создадим парсер, который поместит названия городов в новую колонку City:

def get_city(address): #создание функции

   

    if len(address.split('\\')) > 3 and address.split('\\')[2].isalpha():#условие, если число разделенных слов больше трех и не имеет цифр, тогда верно

        city = address.split('\\')[2].strip() #вывод третьего слова из строки, с разделителем \

        return city #вывод города

    else: #если условие неверно

        return "No Name" #вывод "No Name"

 

df['City'] = df.LOCATION_NAME.apply(get_city)  #применения функции к столбцу с адресом

df = df[df["City"] != "No Name"]         #удаление значений No Name

df.City = df.City.str.capitalize()    #Изменение регистра городов: первая буква заглавная, остальные строчные

df #вывод полученного результата на экран
После того как мы получили геоданные, найдем зависимость : средний чек от города покупки

geo = df[['City','SUM_TRANS']]  #создание выборки с гордом и суммой покупки

geo_sum = geo.groupby(by = "City").mean()   #группировка в зависимости от города с выводом среднего значения суммы покупки

geo = geo_sum.sort_values(by = "SUM_TRANS")  # сортировка по сумме покупки

geo   #вывод результата на экран
После того как мы получили данную зависимость, мы можем визуализировать её с помощью библиотеки MatPlotLib

(Так как значений в таблице довольно много, возьмем для примера каждый 500 - ый случай)

start = geo[::500].head(10) # первые 10 значений с отступом 500

start  # вывод результата на экран
plt.title('средний чек в зависимости от города покупки')              #создание названия таблицы

plt.xlabel('Город')                               #создание названия х - кординат

plt.ylabel('Сумма покупки')                             #создание названия у - кординат

 

plt.gcf().axes[0].yaxis.get_major_formatter().set_scientific(False) #данная команда выводит данные по y, без сокращения.(необязательна)

plt.xticks(rotation='vertical') # расположение месяцев по вертикали

plt.bar(start.index, start.SUM_TRANS)                   #построение графика формата scatter
На этом с первой задачей мы закончили, приступаем ко второй, классификация групп пользователей.

Цель кластеризации данных состоит в том, чтобы выделить группы примеров с похожими чертами и определить соответствие примеров и кластеров. Для себя я выбрал метод кластеризации — «Обучение без учителя». В предыдущей сессии мы определили что одним из самых значимых атрибутов, это возраст, так что, будет отталкиваться от него. А именно сделаем пару выборок в зависимости от данного атрибута и по полученным данным классифицировать группы пользователей

age = df[['AGE','SUM_TRANS', 'MARITAL_STATUS', 'MM_IN_BANK', 'MM_W_CARD', ]]#создание выборки по возрасту

age = age.groupby(by = "AGE").mean() #группировка по возрасту

age = age_sum.sort_values(by = "AGE") #сортировка по возрасту

age
По данной таблице, доволно трудно ориинтироваться, поэтому визуализируем данные зависимости.

#SUM_TRANS    MARITAL_STATUS             MM_IN_BANK   MM_W_CARD

plt.xlabel('возраст покупателя') #создание название х-координат

plt.ylabel('Сумма покупки') #создание название у-координат

plt.plot(age.index, age.SUM_TRANS) #создание графика формата - plot

plt.show() #вывод графика

plt.xlabel('возраст покупателя') #создание название х-координат

plt.ylabel('Материальный статус') #создание название у-координат

plt.plot(age.index, age.MARITAL_STATUS) #создание графика формата - plot

plt.show()  #вывод графика

plt.xlabel('возраст покупателя') #создание название х-координат

plt.ylabel('Время пользования банком') #создание название у-координат

plt.plot(age.index, age.MM_IN_BANK) #создание графика формата - plot

plt.show()  #вывод графика

plt.xlabel('возраст покупателя') #создание название х-координат

plt.ylabel('Время пользования картой') #создание название у-координат

plt.plot(age.index, age.MM_W_CARD) #создание графика формата - plot

plt.show()  #вывод графика
По данным графикам отчетливо виднеется зависимость изменения.

Видно что до 25 лет, от 25 и до 65 и от 60 лет закономерность графика изменяется.

Как вывод можно выделить три группы покупателей:

1) до 25 лет - гр. Студенты

2) от 25 и до 65 лет - гр. Взрослые

3) от 65 и выше - гр. Пенсионеры

 

После того как мы закончили с классификацией пользователей, остаётся лишь сохранить данные выборки для работы в дальнейшем, и написать отчет

 

age.to_csv("age.csv", index=False) #сохранение датафрейма в файл формата csv

geo.to_csv("geo.csv", index=False) #сохранение датафрейма в файл формата csv

df.to_csv("result2.csv", index=False) #сохранение датафрейма в файл формата csv

